package org.nandor.spark;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.apache.avro.ipc.generic.GenericResponder;

public class AdvancedCls extends Clustering {
	
	protected float fractioned = (float)0.35;
	protected float locality = (float) 0.70;
	
	public AdvancedCls(Fog f) {
		super(f);
	}

	public void distributeGw2Cluster(){
		//Concepts: First Come first Serve
		//Concepts: Minimum Fraction Allowed to have a share of
		//Dependent and Independent Gateways, independent ones can be allocated at will 
		this.fog.clearGwClustConns();
		Float totFreeGw = this.fog.getTotalFreeCapacity();
		Float totLoad = this.fog.getTotalLoad();
		Float ratio = totFreeGw/totLoad;
		Map<Integer, List<Integer>> locGws = new HashMap<>();
		for (Integer c: this.fog.getClusters().keySet())
		{
			Float clsLoad = this.fog.getClusters().get(c).getClusterLoad();
			System.out.println("Cluster: "+c+"Apps: "+this.fog.getClusters().get(c).getApps().keySet()+" Load: "+this.fog.getClusters().get(c).getClusterLoad());
			Map<Integer, Integer> gwRes = this.fog.getClusters().get(c).getGwResourcesCount();
			locGws.put(c, new ArrayList<>())
			Float allocLoad = (float) 0.0;
			System.out.println(gwRes);
			//Getting Appropriate number of locality based important Gateways
			while (allocLoad<clsLoad*ratio*locality && !gwRes.isEmpty()){
				int bestIndi = 0;
				int bestIndId = 0;
				for (Integer g: gwRes.keySet()){
					if (gwRes.get(g) > bestIndi){
						bestIndi = gwRes.get(g);
						bestIndId = g;
					}
				}
				locGws.add(bestIndId);
				gwRes.remove(bestIndId);
				//System.out.println(bestIndId+" "+bestIndi);
				allocLoad+=(float)(100.0-this.fog.getGateways().get(bestIndId).getGwLoad())*this.fog.getGateways().get(bestIndId).getPjCap();				
			}
			System.out.println("Gws: "+locGws+" AllocLoad: "+allocLoad );
		}

	}
	
	public void distributeGw2ClusterOld(){
		//Concepts: First Come first Serve
		//Concepts: Minimum Fraction Allowed to have a share of (
		this.fog.clearGwClustConns();
		Float totFreeGw = (float) 0.0;
		Float totClustLoad = (float) 0.0;
		Float totLoad = (float) 0.0;
		Map<Integer, Float> gwLoad = new HashMap<>();
		Map<Integer, Float> gwCoef = new HashMap<>();
		Map<Integer, Float> clsLoad = new HashMap<>();
		Map<Integer, List<Integer>> gwClustLink = new HashMap<>();
		List<Integer> freeGateways = new LinkedList<>();
		Map<Integer, Map<Integer, Float>> gwShare = new HashMap<>();
		// Get Free Gw Load
		for (Integer g : this.fog.getGateways().keySet()) {
			freeGateways.add(g);
			gwShare.put(g, new HashMap<>());
			totLoad += this.fog.getGateways().get(g).getGwLoad();
			gwLoad.put(g, this.fog.getGateways().get(g).getGwLoad());
			gwCoef.put(g, this.fog.getGateways().get(g).getPjCap());
			totFreeGw += ((float) 100.0 - this.fog.getGateways().get(g).getGwLoad())
					*this.fog.getGateways().get(g).getPjCap();
		}
		for (Integer c : this.fog.getClusters().keySet()) {
			clsLoad.put(c, this.fog.getClusters().get(c).getClusterLoad());
			totClustLoad += this.fog.getClusters().get(c).getClusterLoad();
			Map<Integer, Integer> gwRes = this.fog.getClusters().get(c).getGwResourcesCount();
			for (Integer g : gwRes.keySet()) {
				freeGateways.remove(g);
				if (gwClustLink.get(g) == null) {
					List<Integer> tmp = new LinkedList<>();
					tmp.add(c);
					gwClustLink.put(g, tmp);
				} else {
					gwClustLink.get(g).add(c);
				}
			}
		}
		Float adj = totFreeGw / totClustLoad;
		for (Integer i : clsLoad.keySet()) {
			clsLoad.put(i, clsLoad.get(i) * adj);
		}
		// Take each Gateway check how many resources are on it then distribute
		// evenly\
		for (Integer g : gwClustLink.keySet()) {
			Float unit = ((float) 100.0 - gwLoad.get(g)) / (float) gwClustLink.get(g).size();
			for (Integer c : gwClustLink.get(g)) {
				if (clsLoad.get(c) >= (float) 0.0) {
					if (clsLoad.get(c) / gwCoef.get(g) >= unit) {
						gwShare.get(g).put(c, unit);
						gwLoad.put(g, gwLoad.get(g) + unit);
						clsLoad.put(c, clsLoad.get(c) - unit * gwCoef.get(g));
					} else {
						gwShare.get(g).put(c, clsLoad.get(c) / (float) gwCoef.get(g));
						gwLoad.put(g, gwLoad.get(g) + clsLoad.get(c) / (float) gwCoef.get(g));
						clsLoad.put(c, (float) 0.0);
					}
				}
			}
		}
		for (Integer g : gwLoad.keySet()) {
			Float tmp = gwLoad.get(g);
			while (tmp < (float) 99.9) {
				// System.out.println(g+" "+tmp);
				for (Integer c : clsLoad.keySet()) {
					if (clsLoad.get(c) > (float) 0.0) {
						// System.out.println(g+" "+tmp+" "+c+"
						// "+clsLoad.get(c));
						// We have unallocated stuff, now eitehr allocate some
						// or all
						if (((float) 100.0 - tmp) * gwCoef.get(g) > clsLoad.get(c)) {
							// System.out.println("First");
							gwShare.get(g).put(c, clsLoad.get(c) / gwCoef.get(g));
							tmp = tmp + clsLoad.get(c) / gwCoef.get(g);
							clsLoad.put(c, (float) 0.0);
						} else {
							// System.out.println("Second");
							clsLoad.put(c, clsLoad.get(c) - ((float) 100.0 - tmp) * gwCoef.get(g));
							gwShare.get(g).put(c, ((float) 100.0 - tmp));
							tmp = (float) 100.0;
							// Gw Full Break Cluster Loop
							break;
						}
					}
				}
			}
			gwLoad.put(g, tmp);
		}

		// Save Data to the Outside
		for (Integer g : gwShare.keySet()) {
			for (Integer c : gwShare.get(g).keySet()) {
				this.fog.getGateways().get(g).addCluster(this.fog.getClusters().get(c), gwShare.get(g).get(c),
						(float) 100.0 / adj + (float) 10.0);
				this.fog.getClusters().get(c).addGateway(this.fog.getGateways().get(g), gwShare.get(g).get(c),
						(float) 100.0 / adj + (float) 10.0);
			}
		}

		/*
		 * System.out.println("Clust Distribution"); for (Integer i :
		 * gwShare.keySet()) { Float tmp=(float)0.0; for (Integer j :
		 * gwShare.get(i).keySet()) { tmp+=gwShare.get(i).get(j);
		 * System.out.println("Assignment to gw:"+i+" clust:"+j+" of:" +
		 * gwShare.get(i).get(j)); }
		 * System.out.println("Load:"+(gwLoad.get(i))); } for (Integer i :
		 * clsLoad.keySet()) { System.out.println("Cluster Space Left:"
		 * +clsLoad.get(i)); }
		 */
	}
	
}
