package org.nandor.spark;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import org.apache.avro.ipc.generic.GenericResponder;

public class AdvancedCls extends Clustering {
	
	protected float fractioned = (float)35.0;
	protected float locality = (float) 0.70;
	
	public AdvancedCls(Fog f) {
		super(f);
	}

	public void distributeGw2Cluster(){
		//Concepts: First Come first Serve
		//Concepts: Minimum Fraction Allowed to have a share of
		//Dependent (Singular, Shared) and Independent Gateways, independent ones can be allocated at will 
		this.fog.clearGwClustConns();
		Float totFreeGw = this.fog.getTotalFreeCapacity();
		Float totLoad = this.fog.getTotalLoad();
		Float ratio = totFreeGw/totLoad;
		Map<Integer, List<Integer>> locGws = new HashMap<>();
		//Getting Appropriate number of locality based important Gateways
		for (Integer c: this.fog.getClusters().keySet())
		{
			Float clsLoad = this.fog.getClusters().get(c).getClusterLoad();
			//System.out.println("Cluster: "+c+"Apps: "+this.fog.getClusters().get(c).getApps().keySet()+" Load: "+this.fog.getClusters().get(c).getClusterLoad());
			Map<Integer, Integer> gwRes = this.fog.getClusters().get(c).getGwResourcesCount();
			locGws.put(c, new ArrayList<>());
			Float allocLoad = (float) 0.0;
			//System.out.println(gwRes);
			while (allocLoad<clsLoad*ratio*locality && !gwRes.isEmpty()){
				int bestIndi = 0;
				int bestIndId = 0;
				for (Integer g: gwRes.keySet()){
					if (gwRes.get(g) > bestIndi){
						bestIndi = gwRes.get(g);
						bestIndId = g;
					}
				}
				locGws.get(c).add(bestIndId);
				gwRes.remove(bestIndId);
				//System.out.println(bestIndId+" "+bestIndi);
				allocLoad+=(float)(100.0-this.fog.getGateways().get(bestIndId).getGwLoad())*this.fog.getGateways().get(bestIndId).getPjCap();				
			}
			//System.out.println("Gws: "+locGws+" AllocLoad: "+allocLoad );
		}
		//Finding Gateways that are of the three types
		ArrayList<Integer> freeGws = new ArrayList<Integer>(this.fog.getGateways().keySet());
		ArrayList<Integer> sharedGws = new ArrayList<>();
		for (Integer g: locGws.keySet()){
			for (Integer g1: locGws.get(g)){
				if (freeGws.contains(g1)){
					freeGws.remove(g1);
				}else{
					if (!sharedGws.contains(g1)){
						sharedGws.add(g1);
					}
				}
			}
		}
		//Removing the average shared one 
		for (Integer gShare: sharedGws){
			boolean found = false;
			//Leave at first then remove from rest
			List<Integer> i = new ArrayList<Integer>(locGws.keySet());
			Collections.shuffle(i);
			for (Integer g: i){
				List<Integer> j = new ArrayList<Integer>(locGws.get(g));
				for (Integer g1: j){
					if (g1==gShare && !found){
						found = true;
					}else if (g1==gShare && found){
						locGws.get(g).remove(gShare);
					}
				}
			}
		}
		//System.out.println(locGws);
		//System.out.println(freeGws);
		//System.out.println(sharedGws);
		//Do Final Allocations of Gws to Clusters
		Map<Integer,Float> shareLeft = new HashMap<>();
		for (Integer c: locGws.keySet()){
			//Allocate each individual Gw to Cluster and calculate how much is needed and add all full portions 
			//System.out.print("Cluster: "+c);
			Float allocRes = (float) 0.0;
			List<Integer> j = new ArrayList<Integer>(locGws.get(c));
			for (Integer g:j){
				Float res = (float)(100.0 - this.fog.getGateways().get(g).getGwLoad())*this.fog.getGateways().get(g).getPjCap();
				if(allocRes+res<this.fog.getClusters().get(c).getClusterLoad()*0.95*ratio){
					allocRes+=res;
				}else{
					locGws.get(c).remove(g);
					freeGws.add(g);
				}
			}
			//System.out.print(" 1. Alloc: "+allocRes+ " Tot: "+this.fog.getClusters().get(c).getClusterLoad()*0.95*ratio);
			//Add from free until full
			List<Integer> j2 = new ArrayList<Integer>(freeGws);
			for (Integer g:j2){
				Float res = (100 - this.fog.getGateways().get(g).getGwLoad())*this.fog.getGateways().get(g).getPjCap();
				if(allocRes+res<this.fog.getClusters().get(c).getClusterLoad()*0.95*ratio){
					allocRes+=res;
					locGws.get(c).add(g);
					freeGws.remove(g);
				}
			}
			//System.out.println(" 2. Alloc: "+allocRes+ " Tot: "+this.fog.getClusters().get(c).getClusterLoad()*0.95*ratio);
			shareLeft.put(c, this.fog.getClusters().get(c).getClusterLoad()*ratio-allocRes);
		}
		System.out.println(shareLeft);
		System.out.println(freeGws);
		//Chekc how the final gateways Behave and how those are split up, maybe they should be shared 
		Map<Integer,Float> allocGws = new HashMap<>();
		for (Integer g:freeGws){
			allocGws.put(g, this.fog.getGateways().get(g).getFreeLoad());
		}
		List<Integer> j3 = new ArrayList<Integer>(shareLeft.keySet());
		for (Integer c: j3){
			// Check if any gw can store this while retaining % of space left //fractioned = (float)0.35;
			for (Integer g:freeGws){
				if (allocGws.get(g)-fractioned > shareLeft.get(c)){
					allocGws.put(g, allocGws.get(g)-shareLeft.get(c));
					//TODO - Need to Actually do this allocation - actuall value in % share
					 shareLeft.remove(c);
					 break;
				}else if (allocGws.get(g)*0.95 < shareLeft.get(c) && allocGws.get(g)*1.05 > shareLeft.get(c)){
					allocGws.put(g, allocGws.get(g)-shareLeft.get(c));
					//TODO - Need to Actually do this allocation - take as 100% share
					 shareLeft.remove(c);
					 break;
				}
			}
		}
		System.out.println(shareLeft);
		System.out.println(allocGws);
		//Give Up Fill-Em Up
		for (Integer c: shareLeft.keySet()){
			Float req=shareLeft.get(c);			
			while (req>=0.0 && allocGws.size()>0){
				allocGws.keySet().toArray(new List<Integer>())
				if (allocGws.get(0)>req){
					allocGws.put(0,allocGws.get(0)-req);
					//TODO  - Need to Actually do this allocation 
					req=(float)0.0;
				}else{
					req=req-allocGws.get(0);
					//TODO  - Need to Actually do this allocation 
					allocGws.remove(0);
				}
			}
		}
	}
	
	
}
