package org.nandor.spark;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

public class WeightedCls extends Clustering{

	protected Map<String, Double> simWeights = new HashMap<>();
	
	public WeightedCls(Fog f) {
		super(f);
	}
	//Connections in a way that is not directional
	public Map<Integer,List<Integer>> getConnections(){
		Map<Integer,List<Integer>> nodes = new HashMap<>();
		for (Integer p: this.fog.getApps().keySet()){
			if (nodes.containsKey(p)){
				nodes.get(p).addAll(this.fog.getApps().get(p).getApps().keySet());
			}else{
				List<Integer> point = new ArrayList<>();
				point.addAll(this.fog.getApps().get(p).getApps().keySet());
				nodes.put(p, point);
			}
			for (Integer pBack: this.fog.getApps().get(p).getApps().keySet()){
					if (nodes.containsKey(pBack)){
						nodes.get(pBack).add(p);
					}else{
						List<Integer> pointBack = new ArrayList<>();
						pointBack.add(p);
						nodes.put(pBack, pointBack);
					}
				}
		}
		for (Integer p: nodes.keySet()){
			List<Integer> deDupStringList = new ArrayList<>(new HashSet<>(nodes.get(p)));
			nodes.put(p, deDupStringList);
			
		}
		//System.out.println(nodes);
		return nodes;
	}

	public  Map<String, Double> getSimilarities(Integer p1,Integer p2){	
		//Inti
		Map<String,Double> ret = new HashMap<>();
		/*
		 * Need to make sure that these methods and non-directional so dist p1-p2 == dist p2-p1 in all cases
		 * The values found can be totally arbitrary as later on they will be compared to a min and max in the 
		 * and given weights based on correlation parameters 
		 */
		//Connection Distance
		ret.put("Distance", this.dijkstraSearsch(p1, p2));
		//Resource Location share
		ret.put("ResourceShare",this.getResShare(p1,p2));
		//Constraint Component
		ret.put("Constraints",this.getConstSim(p1,p2));
		//Msg Rate
		ret.put("MessageRate",this.getMsgRateComp(p1,p2));
		//Unit Load
		ret.put("UnitLoad",this.getUnitLoadComp(p1,p2));
		//Utility Weights ratio
		ret.put("UtilityWeights",this.getUtilityComp(p1,p2));
		//Requirements
		ret.put("RequirementSim",this.getReqComp(p1,p2));
		
		//Return
		return ret;
	}
	
	//Methods for getting Similarities
	private Double getResShare(Integer p1, Integer p2) {
		Double sim = 0.0;
		Double sim2 = 0.0;
		boolean found = false;
		//Find all Resources that share a gw from p1 to p2
		for (Integer res: this.fog.getApps().get(p1).getResources().keySet()){
			for (Integer res2: this.fog.getApps().get(p2).getResources().keySet()){
				if (this.fog.getResources().get(res).getGateway().getId()==this.fog.getResources().get(res2).getGateway().getId()){
					sim+=1.0;
					break;
				}
			}
		}
		//Find all Resources that share a gw from p2 to p1
		for (Integer res: this.fog.getApps().get(p2).getResources().keySet()){
			for (Integer res2: this.fog.getApps().get(p1).getResources().keySet()){
				if (this.fog.getResources().get(res).getGateway().getId()==this.fog.getResources().get(res2).getGateway().getId()){
					sim2+=1.0;
					break;
				}
			}
		}
		/*System.out.println(sim);
		System.out.println(sim2);
		System.out.println(this.fog.getApps().get(p1).getResources().size());
		System.out.println(this.fog.getApps().get(p2).getResources().size());*/
		//Return the number of resources shared for each app divided by total and multiplied 
		//ret = share1/tot1 * share2/tot2; where 
		//share[x] - total number of resources for app x that shares a gw with the other app; tot[x]-tot res count
		Double ret = sim/this.fog.getApps().get(p1).getResources().size()*sim2/this.fog.getApps().get(p2).getResources().size();
		return ret;
	}
	
	private Double getConstSim(Integer p1, Integer p2) {
		// Check if they have constraints or not, and if they have these on the same thing
		Double constVal = 0.0;
		for (String ct: this.fog.getApps().get(p1).getConstraints().keySet()){
			if (this.fog.getApps().get(p2).getConstraints().get(ct)!=null){
				//We have found a constraint that both of them have,
				//first check if same type (existing, non existing)
				//check difference if existing
				Float ct1 = this.fog.getApps().get(p1).getConstraints().get(ct);
				Float ct2 = this.fog.getApps().get(p2).getConstraints().get(ct);
				/*if ((ct1 == Float.MAX_VALUE && ct2 == Float.MAX_VALUE) || ( ct2 == Float.MIN_VALUE && ct1 == Float.MIN_VALUE)){
					//Neither has a constraint
					System.out.println("No Constraints");
				}*/
				if ((ct1 != Float.MAX_VALUE && ct2 != Float.MAX_VALUE) && ( ct2 != Float.MIN_VALUE && ct1 != Float.MIN_VALUE)){
					//Both have constraints, compare
					//System.out.println("Both have Constraints, compare then");
					//System.out.println(ct1+" "+ct2);
					//System.out.println(this.relDiff((double)ct1,(double) ct2));
					constVal +=(1.0-this.relDiff((double)ct1,(double) ct2));
				}
			}
		}
		/*System.out.println(constVal);
		System.out.println(this.fog.getApps().get(p1).getConstraints().size());
		System.out.println(this.fog.getApps().get(p2).getConstraints().size());*/
		//ret = ct/tot1 * ct/tot2; where 
		//ct - existing constraint diffrences; tot[x]-tot constraint count
		Double ret = constVal/this.fog.getApps().get(p1).getConstraints().size()*constVal/this.fog.getApps().get(p2).getConstraints().size();
		return ret;
	}
	
	
	private Double getMsgRateComp(Integer p1, Integer p2) {
		//System.out.println((1-relDiff((double)this.fog.getApps().get(p1).getTotalMsgRate(),(double)this.fog.getApps().get(p2).getTotalMsgRate())));
		//Similarity between the two message rates
		return (1-relDiff((double)this.fog.getApps().get(p1).getTotalMsgRate(),(double)this.fog.getApps().get(p2).getTotalMsgRate()));
	}
	
	private Double getUnitLoadComp(Integer p1, Integer p2) {
		//System.out.println((1-relDiff((double)this.fog.getApps().get(p1).getUnitLoad(),(double)this.fog.getApps().get(p2).getUnitLoad())));
		//Similarity between the two Unit Loads
		return (1-relDiff((double)this.fog.getApps().get(p1).getUnitLoad(),(double)this.fog.getApps().get(p2).getUnitLoad()));
	}
	private Double getUtilityComp(Integer p1, Integer p2) {
		// Check if they have constraints or not, and if they have these on the same thing
		Double utiltVal = 0.0;
		for (String ct: this.fog.getApps().get(p1).getUtilityWeights().keySet()){
			if (this.fog.getApps().get(p2).getConstraints().get(ct)!=null){
				//We have found a constraint that both of them have,
				//first check if same type (existing, non existing)
				//check difference if existing
				Float u1 = this.fog.getApps().get(p1).getConstraints().get(ct);
				Float u2 = this.fog.getApps().get(p2).getConstraints().get(ct);
				utilVal +=(1.0-this.relDiff((double)u1,(double) u2));
			}
		}
		/*System.out.println(constVal);
		System.out.println(this.fog.getApps().get(p1).getConstraints().size());
		System.out.println(this.fog.getApps().get(p2).getConstraints().size());*/
		//ret = ct/tot1 * ct/tot2; where 
		//ct - existing constraint diffrences; tot[x]-tot constraint count
		Double ret = constVal/this.fog.getApps().get(p1).getConstraints().size()*constVal/this.fog.getApps().get(p2).getConstraints().size();
		return ret;
	}
	private Double getReqComp(Integer p1, Integer p2) {
		Double sim = 0.0;
		Double sim2 = 0.0;
		//Find all Requirements that are similar
		for (String req: this.fog.getApps().get(p1).getRequirements()){
			for (String req2: this.fog.getApps().get(p2).getRequirements()){
				if (req.compareTo(req2)==0){
					sim+=1.0;
					break;
				}
			}
		}
		//Find all Requirements that are similar
		for (String req: this.fog.getApps().get(p2).getRequirements()){
			for (String req2: this.fog.getApps().get(p1).getRequirements()){
				if (req.compareTo(req2)==0){
					sim2+=1.0;
					break;
				}
			}
		}
		//Return the number of requirements shared for each app divided by total and multiplied 
		//ret = share1/tot1 * share2/tot2; where 
		//share[x] - total number of requirements for app x the other app has ; tot[x]-tot req count
		Double ret = sim/this.fog.getApps().get(p1).getRequirements().size()*sim2/this.fog.getApps().get(p2).getRequirements().size();
		return ret;
	}
	
	//Extra Methods, usefull
	public Double relDiff(Double x,Double y){
		//Get RelativeDiffrence of two numbers
		// RelDiff = | x - y | / max(|x|,|y|)
		// |x| = sqrt(x^2)
		if (x.compareTo(y)==0){
			return 0.0;
		}else{
			return Math.sqrt((x-y)*(x-y))/Math.max(Math.sqrt(x*x),Math.sqrt(y*y));
		}
	}
	
}
