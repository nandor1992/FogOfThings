package org.nandor.spark;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class WeightedCls extends Clustering {

	protected Map<String, Double> appWeights = new HashMap<>();
	protected Map<String, Double> gwWeights = new HashMap<>();
	public WeightedCls(Fog f) {
		super(f);
	}

	// Connections in a way that is not directional
	public Map<Integer, List<Integer>> getConnections() {
		Map<Integer, List<Integer>> nodes = new HashMap<>();
		for (Integer p : this.fog.getApps().keySet()) {
			if (nodes.containsKey(p)) {
				nodes.get(p).addAll(this.fog.getApps().get(p).getApps().keySet());
			} else {
				List<Integer> point = new ArrayList<>();
				point.addAll(this.fog.getApps().get(p).getApps().keySet());
				nodes.put(p, point);
			}
			for (Integer pBack : this.fog.getApps().get(p).getApps().keySet()) {
				if (nodes.containsKey(pBack)) {
					nodes.get(pBack).add(p);
				} else {
					List<Integer> pointBack = new ArrayList<>();
					pointBack.add(p);
					nodes.put(pBack, pointBack);
				}
			}
		}
		for (Integer p : nodes.keySet()) {
			List<Integer> deDupStringList = new ArrayList<>(new HashSet<>(nodes.get(p)));
			nodes.put(p, deDupStringList);

		}
		// System.out.println(nodes);
		return nodes;
	}

	// Correlation Stuff
	// TODO Just a marker
	public Map<String, Double> Correlation(String variable, List<Map<String, Double>> data) {
		Map<String, Double> ret = new HashMap<>();
		// Assume that the first is representative
		for (String n : data.get(0).keySet()) {
			if (n != variable) {
				ret.put(n, CorrelationByVar(n, variable, data));
			}
		}
		return ret;
	}

	// Similarities between all points
	public Double CorrelationByVar(String variable2, String variable, List<Map<String, Double>> data) {

		// Using the equation
		// Pearson R Correlation
		// Rxy=1/(n-1)*(Sum_x,y((x-x')*(y-y')))/(Sx*Sy)
		// Where R[x,y] - Correlation between x and y
		// n - total number of data points
		// x,y - single data points
		// x',y' - Mean of all values of x and y
		// Sx,Sy - Standard Deviation for x and y

		// List<Map<String, Double>> data = allSimilarities();
		// System.out.println("Corr on Variable: "+variable+" Data Size:
		// "+data.size());

		// Check if any variable is NaN
		for (Map<String, Double> point : data) {
			for (String n : point.keySet()) {
				if (point.get(n).isNaN()) {
					//System.out.println("Point is NaN:" + point);
				}
			}
		}
		// Get the mean of the Deployments on the samme GW
		Double meanGw = 0.0;
		for (Map<String, Double> point : data) {
			meanGw += point.get(variable2);
		}
		meanGw = meanGw / data.size();
		// System.out.println("Mean Gw: "+meanGw);

		// Get the mean of the Distance Variable
		Double meanVar = 0.0;
		for (Map<String, Double> point : data) {
			meanVar += point.get(variable);
		}
		meanVar = meanVar / data.size();
		// System.out.println("Mean Var: "+meanVar);

		// Standard Deviation of Gw values
		Double stdGw = 0.0;
		for (Map<String, Double> point : data) {
			stdGw += (point.get(variable2) - meanGw) * (point.get(variable2) - meanGw);
		}
		stdGw = Math.sqrt(stdGw / (data.size() - 1));
		// System.out.println("Standard Dev Gw: "+stdGw);

		// Standard Deviation of Variable values
		Double stdVar = 0.0;
		for (Map<String, Double> point : data) {
			stdVar += (point.get(variable) - meanVar) * (point.get(variable) - meanVar);
		}
		stdVar = Math.sqrt(stdVar / (data.size() - 1));
		// System.out.println("Standard Dev Variable: "+stdVar);

		// Calculating the top part of the equation
		Double topSum = 0.0;
		for (Map<String, Double> point : data) {
			topSum += (point.get(variable2) - meanGw) * (point.get(variable) - meanVar);
		}
		// Return correlation value of the two variables
		Double corr = topSum / (stdVar * stdGw) / (data.size() - 1);
		// System.out.println("R: "+corr);
		// System.out.println("R^2: "+corr*corr);
		// In case of dummb/dummy data
		if (stdVar.isNaN() || stdGw.isNaN() || corr.isNaN()) {
			return 0.0;
		}
		return corr;
	}

	// App Similarities
	// TODO marker
	public List<Map<String, Double>> allGwSimilarities() {
		List<Map<String, Double>> ret = new ArrayList();
		// get all values for all Apps deployed check if they are on the same gw
		List<Integer> visited = new ArrayList();
		for (Integer a : this.fog.getApps().keySet()) {
			for (Integer g : this.fog.getGateways().keySet()) {
				Map<String, Double> tmp = getGwSimilarities(a, g);
				if (this.fog.getApps().get(a).getGateway().getId() == g) {
					tmp.put("Deployment", 1.0);
				} else {
					tmp.put("Deployment", 0.0);
				}
				ret.add(tmp);
			}
		}
		return ret;
	}
	//All gw similarities for the Gws
	public List<Map<String, Double>> allGwSimilarities(List<Map<Integer, Integer>> bests) {
		List<Map<String, Double>> ret = new ArrayList();
		// get all values for all Apps deployed check if they are on the same gw
		for (Map<Integer, Integer> b : bests) {
			this.fog.clearAppToGws();
			this.fog.AssignAppsToGws(b);
			if (this.fog.verifyIndValidity() && this.fog.checkIfAppsAllocated().size() == 0) {
				List<Integer> visited = new ArrayList();
				for (Integer a : this.fog.getApps().keySet()) {
					for (Integer g : this.fog.getGateways().keySet()) {
						Map<String, Double> tmp = getGwSimilarities(a, g);
						if (this.fog.getApps().get(a).getGateway().getId() == g) {
							tmp.put("Deployment", this.fog.getFogCompoundUtility().doubleValue());
							ret.add(tmp);
						} else {
							tmp.put("Deployment", 0.0);
							ret.add(tmp);
						}
					}
				}
			}
		}
		return ret;
	}

	// Similarities between points
	public Map<String, Double> getGwSimilarities(Integer a, Integer g) {
		// Init
		Map<String, Double> ret = new HashMap<>();
		// Find parameters that you may think that inlfuences why apps chose
		// Gateways

		// Get Min and Max Values

		Map<String, Map<String, Double>> minMax = getMinMaxs();
		//System.out.println(minMax);
		// Whether having similar capability/requirements helps
		ret.put("Capabilities", this.appToGwCapability(a, g));

		// Whether the performance Coefficient and the Unit Load are Linked as
		// per size
		ret.put("PerfToULoad", this.perfToULoad(a, g, minMax));

		// Whether the capacity of the gateway links to the Unit load
		ret.put("CapToULoad", this.capToULoad(a, g, minMax));

		// Whether having resources on the Gateway helps the application
		ret.put("SharedRes", this.gwResShare(a, g));

		// Whether having a base load of any kind helps the app be on the
		// gateway
		ret.put("BaseLoad", this.gwBaseToApp(a, g, minMax));
		return ret;
	}

	// Whether having similar capability/requirements helps
	private Double appToGwCapability(Integer a, Integer g) {
		Double sim = 0.0;
		// Find all Requirements that are similar
		for (String req : this.fog.getApps().get(a).getRequirements()) {
			for (String req2 : this.fog.getGateways().get(g).getCapabilities()) {
				if (req.compareTo(req2) == 0) {
					sim += 1.0;
					break;
				}
			}
		}
		// Return the number of requirements shared for each app divided by
		// total and multiplied
		// ret = share1/tot1 * share2/tot2; where
		// share[x] - total number of requirements for app x the other app has ;
		// tot[x]-tot req count
		Double ret = sim / this.fog.getApps().get(a).getRequirements().size();
		return ret;
	}

	// Whether having resources on the Gateway helps the application
	private Double gwResShare(Integer a, Integer g) {
		Double sim = 0.0;
		// Find all Resources that share a gw from p1 to p2
		for (Integer res : this.fog.getApps().get(a).getResources().keySet()) {
			if (this.fog.getResources().get(res).getGateway().getId() == g) {
				sim += 1.0;
			}
		}
		if (this.fog.getApps().get(a).getResources().size() == 0) {
			return 0.0;
		}
		Double ret = sim / this.fog.getApps().get(a).getResources().size();
		return ret;
	}

	// Whether the performance Coefficient and the Unit Load are Linked as per
	private Double perfToULoad(Integer a, Integer g, Map<String, Map<String, Double>> minMax) {
		Double pC = this.fog.getGateways().get(g).getPjSpeed().doubleValue();
		Double uL = this.fog.getApps().get(a).getUnitLoad().doubleValue();
		//Return the absolute diffrence between the twos positioning in the min and max 
		//pcRel = pc/(max-min)+min
		Double pCRel;
		Double ulRel;
		if (minMax.get("perf").get("max")==minMax.get("perf").get("min")){
			pCRel = 1.0;
		}else{
			pCRel = (pC-minMax.get("perf").get("min"))/(minMax.get("perf").get("max")-minMax.get("perf").get("min"));
		}
		if (minMax.get("uLoad").get("max")==minMax.get("uLoad").get("min")){
			ulRel = 1.0;
		}else{
			ulRel = (uL-minMax.get("uLoad").get("min"))/(minMax.get("uLoad").get("max")-minMax.get("uLoad").get("min"));
		}
		/*System.out.println(pC);
		System.out.println(uL);
		System.out.println(pCRel);
		System.out.println(ulRel);
		if (this.relDiff(pCRel,ulRel).isNaN()){
			System.out.println(pC);
			System.out.println(uL);
			System.out.println(pCRel);
			System.out.println(ulRel);
		}*/
		return (1.0-this.relDiff(pCRel,ulRel));
	}

	// Whether the capacity of the gateway links to the Unit load
	private Double capToULoad(Integer a, Integer g, Map<String, Map<String, Double>> minMax) {
		Double cC = this.fog.getGateways().get(g).getPjCap().doubleValue();
		Double uL = this.fog.getApps().get(a).getUnitLoad().doubleValue();
		//Return the absolute diffrence between the twos positioning in the min and max 
		//pcRel = pc/(max-min)+min
		Double cCRel;
		Double ulRel;
		if (minMax.get("cap").get("max")==minMax.get("cap").get("min")){
			cCRel = 1.0;
		}else{
			cCRel = (cC-minMax.get("cap").get("min"))/(minMax.get("cap").get("max")-minMax.get("cap").get("min"));
		}
		if (minMax.get("uLoad").get("max")==minMax.get("uLoad").get("min")){
			ulRel = 1.0;
		}else{
			ulRel = (uL-minMax.get("uLoad").get("min"))/(minMax.get("uLoad").get("max")-minMax.get("uLoad").get("min"));
		}
		/*System.out.println(cC);
		System.out.println(uL);
		System.out.println(cCRel);
		System.out.println(ulRel);*/
		return (1.0-this.relDiff(cCRel,ulRel));
	}

	// Whether having a base load of any kind helps the app be on the gateway
	private Double gwBaseToApp(Integer a, Integer g, Map<String, Map<String, Double>> minMax) {
		Double bLoad = this.fog.getGateways().get(g).getGwBaseLoad().doubleValue();
		Double uL = this.fog.getApps().get(a).getUnitLoad().doubleValue();
		//Return the absolute diffrence between the twos positioning in the min and max 
		//pcRel = pc/(max-min)+min
		bLoad = bLoad/100.0;
		Double ulRel;
		if (minMax.get("uLoad").get("max")==minMax.get("uLoad").get("min")){
			ulRel = 1.0;
		}else{
			ulRel = (uL-minMax.get("uLoad").get("min"))/(minMax.get("uLoad").get("max")-minMax.get("uLoad").get("min"));
		}
		/*System.out.println(bLoad);
		System.out.println(uL);
		System.out.println(ulRel);*/
		return (1.0-this.relDiff(bLoad,ulRel));
	}
	
	// Get minimum and max values for future reference
	private Map<String, Map<String, Double>> getMinMaxs() {
		Map<String, Map<String, Double>> ret = new HashMap<>();
		Map<String, Double> perfCoeff = new HashMap<>();
		Map<String, Double> capCoeff = new HashMap<>();
		Map<String, Double> uLoad = new HashMap<>();
		Double pCMax = 0.0;
		Double cCMax = 0.0;
		Double pCMin = Double.MAX_VALUE;
		Double cCMin = Double.MAX_VALUE;
		for (Integer g : this.fog.getGateways().keySet()) {
			Double pC = this.fog.getGateways().get(g).getPjSpeed().doubleValue();
			Double cC = this.fog.getGateways().get(g).getPjCap().doubleValue();
			if (pC > pCMax) {
				pCMax = pC;
			}
			if (pC < pCMin) {
				pCMin = pC;
			}
			if (cC > cCMax) {
				cCMax = cC;
			}
			if (cC < cCMin) {
				cCMin = cC;
			}
		}
		perfCoeff.put("min", pCMin);
		perfCoeff.put("max", pCMax);
		capCoeff.put("min", cCMin);
		capCoeff.put("max", cCMax);
		Double uLMax = 0.0;
		Double uLMin = Double.MAX_VALUE;
		for (Integer a : this.fog.getApps().keySet()) {
			Double uL = this.fog.getApps().get(a).getUnitLoad().doubleValue();
			if (uL > uLMax) {
				uLMax = uL;
			}
			if (uL < uLMin) {
				uLMin = uL;
			}
		}
		uLoad.put("min", uLMin);
		uLoad.put("max", uLMax);
		ret.put("perf", perfCoeff);
		ret.put("cap", capCoeff);
		ret.put("uLoad", uLoad);
		return ret;
	}

	// App Similarities
	// TODO marker
	public List<Map<String, Double>> allAppSimilarities() {
		List<Map<String, Double>> ret = new ArrayList();
		// get all values for all Apps deployed check if they are on the same gw
		List<Integer> visited = new ArrayList();
		for (Integer a1 : this.fog.getApps().keySet()) {
			for (Integer a2 : this.fog.getApps().keySet()) {
				if (a1 != a2 && !visited.contains(a2)) {
					Map<String, Double> tmp = getAppSimilarities(a1, a2);
					if (this.fog.getApps().get(a1).getGateway().getId() == this.fog.getApps().get(a2).getGateway()
							.getId()) {
						tmp.put("Deployment", 1.0);
					} else {
						tmp.put("Deployment", 0.0);
					}
					ret.add(tmp);
				}
			}
			visited.add(a1);
		}
		return ret;
	}
	//Get best from a number of bests
	public List<Map<String, Double>> allAppSimilarities(List<Map<Integer, Integer>> bests) {
		//TODO Make it to bests
		List<Map<String, Double>> ret = new ArrayList();
		// get all values for all Apps deployed check if they are on the same gw
		List<Integer> visited = new ArrayList();
		for (Integer a1 : this.fog.getApps().keySet()) {
			for (Integer a2 : this.fog.getApps().keySet()) {
				if (a1 != a2 && !visited.contains(a2)) {
					Map<String, Double> tmp = getAppSimilarities(a1, a2);
					if (this.fog.getApps().get(a1).getGateway().getId() == this.fog.getApps().get(a2).getGateway()
							.getId()) {
						tmp.put("Deployment", this.fog.getFogCompoundUtility().doubleValue());
						ret.add(tmp);
					} else {
						tmp.put("Deployment", 0.0);
						ret.add(tmp);
					}
				}
			}
			visited.add(a1);
		}
		return ret;
	}

	// Similarities between points
	public Map<String, Double> getAppSimilarities(Integer p1, Integer p2) {
		// Inti
		Map<String, Double> ret = new HashMap<>();
		/*
		 * Need to make sure that these methods and non-directional so dist
		 * p1-p2 == dist p2-p1 in all cases The values found can be totally
		 * arbitrary as later on they will be compared to a min and max in the
		 * and given weights based on correlation parameters
		 */
		// Connection Distance
		ret.put("Distance", this.dijkstraSearsch(p1, p2));
		// Resource Location share
		ret.put("ResourceShare", this.getResShare(p1, p2));
		// Constraint Component
		ret.put("Constraints", this.getConstSim(p1, p2));
		// Msg Rate
		ret.put("MessageRate", this.getMsgRateComp(p1, p2));
		// Unit Load
		ret.put("UnitLoad", this.getUnitLoadComp(p1, p2));
		// Utility Weights ratio
		ret.put("UtilityWeights", this.getUtilityComp(p1, p2));
		// Requirements
		ret.put("RequirementSim", this.getReqComp(p1, p2));

		// Return
		return ret;
	}

	// Methods for getting Similarities
	private Double getResShare(Integer p1, Integer p2) {
		Double sim = 0.0;
		Double sim2 = 0.0;
		boolean found = false;
		// Find all Resources that share a gw from p1 to p2
		if (this.fog.getApps().get(p1).getResources().size() == 0
				|| this.fog.getApps().get(p2).getResources().size() == 0) {
			return 0.0;
		}	
		for (Integer res : this.fog.getApps().get(p1).getResources().keySet()) {
			for (Integer res2 : this.fog.getApps().get(p2).getResources().keySet()) {
				if (this.fog.getResources().get(res).getGateway().getId() == this.fog.getResources().get(res2)
						.getGateway().getId()) {
					sim += 1.0;
					break;
				}
			}
		}
		// Find all Resources that share a gw from p2 to p1
		for (Integer res : this.fog.getApps().get(p2).getResources().keySet()) {
			for (Integer res2 : this.fog.getApps().get(p1).getResources().keySet()) {
				if (this.fog.getResources().get(res).getGateway().getId() == this.fog.getResources().get(res2)
						.getGateway().getId()) {
					sim2 += 1.0;
					break;
				}
			}
		}
		/*
		 * System.out.println(sim); System.out.println(sim2);
		 * System.out.println(this.fog.getApps().get(p1).getResources().size());
		 * System.out.println(this.fog.getApps().get(p2).getResources().size());
		 */
		// Return the number of resources shared for each app divided by total
		// and multiplied
		// ret = share1/tot1 * share2/tot2; where
		// share[x] - total number of resources for app x that shares a gw with
		// the other app; tot[x]-tot res count
		Double ret = sim / this.fog.getApps().get(p1).getResources().size() * sim2
				/ this.fog.getApps().get(p2).getResources().size();
		return ret;
	}

	private Double getConstSim(Integer p1, Integer p2) {
		// Check if they have constraints or not, and if they have these on the
		// same thing
		Double constVal = 0.0;
		for (String ct : this.fog.getApps().get(p1).getConstraints().keySet()) {
			if (this.fog.getApps().get(p2).getConstraints().get(ct) != null) {
				// We have found a constraint that both of them have,
				// first check if same type (existing, non existing)
				// check difference if existing
				Float ct1 = this.fog.getApps().get(p1).getConstraints().get(ct);
				Float ct2 = this.fog.getApps().get(p2).getConstraints().get(ct);
				/*
				 * if ((ct1 == Float.MAX_VALUE && ct2 == Float.MAX_VALUE) || (
				 * ct2 == Float.MIN_VALUE && ct1 == Float.MIN_VALUE)){ //Neither
				 * has a constraint System.out.println("No Constraints"); }
				 */
				if ((ct1 != Float.MAX_VALUE && ct2 != Float.MAX_VALUE)
						&& (ct2 != Float.MIN_VALUE && ct1 != Float.MIN_VALUE)) {
					// Both have constraints, compare
					// System.out.println("Both have Constraints, compare
					// then");
					// System.out.println(ct1+" "+ct2);
					// System.out.println(this.relDiff((double)ct1,(double)
					// ct2));
					constVal += (1.0 - this.relDiff((double) ct1, (double) ct2));
				}
			}
		}
		/*
		 * System.out.println(constVal);
		 * System.out.println(this.fog.getApps().get(p1).getConstraints().size()
		 * );
		 * System.out.println(this.fog.getApps().get(p2).getConstraints().size()
		 * );
		 */
		// ret = ct/tot1 * ct/tot2; where
		// ct - existing constraint diffrences; tot[x]-tot constraint count
		Double ret = constVal / this.fog.getApps().get(p1).getConstraints().size() * constVal
				/ this.fog.getApps().get(p2).getConstraints().size();
		return ret;
	}

	private Double getMsgRateComp(Integer p1, Integer p2) {
		// System.out.println((1-relDiff((double)this.fog.getApps().get(p1).getTotalMsgRate(),(double)this.fog.getApps().get(p2).getTotalMsgRate())));
		// Similarity between the two message rates
		return (1 - relDiff((double) this.fog.getApps().get(p1).getTotalMsgRate(),
				(double) this.fog.getApps().get(p2).getTotalMsgRate()));
	}

	private Double getUnitLoadComp(Integer p1, Integer p2) {
		// System.out.println((1-relDiff((double)this.fog.getApps().get(p1).getUnitLoad(),(double)this.fog.getApps().get(p2).getUnitLoad())));
		// Similarity between the two Unit Loads
		return (1 - relDiff((double) this.fog.getApps().get(p1).getUnitLoad(),
				(double) this.fog.getApps().get(p2).getUnitLoad()));
	}

	private Double getUtilityComp(Integer p1, Integer p2) {
		// Check if they have utilityweights or not, and if they have these on
		// the same thing
		Double utilVal = 0.0;
		for (String u : this.fog.getApps().get(p1).getUtilityWeights().keySet()) {
			if (this.fog.getApps().get(p2).getUtilityWeights().get(u) != null) {
				// We have found a constraint that both of them have,
				// first check if same type (existing, non existing)
				// check difference if existing
				Float u1 = this.fog.getApps().get(p1).getUtilityWeights().get(u);
				Float u2 = this.fog.getApps().get(p2).getUtilityWeights().get(u);
				utilVal += (1.0 - this.relDiff((double) u1, (double) u2));
			}
		}
		// ret = u/tot1 * u/tot2; where
		// u - existing utility weight diffrences; tot[x]-tot utility weight
		// count
		Double ret = utilVal / this.fog.getApps().get(p1).getUtilityWeights().size() * utilVal
				/ this.fog.getApps().get(p2).getUtilityWeights().size();
		return ret;
	}

	private Double getReqComp(Integer p1, Integer p2) {
		Double sim = 0.0;
		Double sim2 = 0.0;
		// Find all Requirements that are similar
		for (String req : this.fog.getApps().get(p1).getRequirements()) {
			for (String req2 : this.fog.getApps().get(p2).getRequirements()) {
				if (req.compareTo(req2) == 0) {
					sim += 1.0;
					break;
				}
			}
		}
		// Find all Requirements that are similar
		for (String req : this.fog.getApps().get(p2).getRequirements()) {
			for (String req2 : this.fog.getApps().get(p1).getRequirements()) {
				if (req.compareTo(req2) == 0) {
					sim2 += 1.0;
					break;
				}
			}
		}
		// Return the number of requirements shared for each app divided by
		// total and multiplied
		// ret = share1/tot1 * share2/tot2; where
		// share[x] - total number of requirements for app x the other app has ;
		// tot[x]-tot req count
		Double ret = sim / this.fog.getApps().get(p1).getRequirements().size() * sim2
				/ this.fog.getApps().get(p2).getRequirements().size();
		return ret;
	}

	// Extra Methods, usefull
	public Double relDiff(Double x, Double y) {
		// Get RelativeDiffrence of two numbers
		// RelDiff = | x - y | / max(|x|,|y|)
		// |x| = sqrt(x^2)
		if (x.compareTo(y) == 0) {
			return 0.0;
		} else {
			return Math.sqrt((x - y) * (x - y)) / Math.max(Math.sqrt(x * x), Math.sqrt(y * y));
		}
	}
	

	// Modified and Re-Implemented
	public Double dijkstraSearsch(Integer p, Integer p2) {
		// Init
		List<Integer> queue = new ArrayList<>();
		Map<Integer, Integer> prev = new HashMap<>();
		Map<Integer, Double> dist = new HashMap<>();
		for (Integer i : this.nodes.keySet()) {
			dist.put(i, Double.POSITIVE_INFINITY);
			prev.put(i, null);
			queue.add(i);
		}
		dist.put(p, 0.0);
		while (queue.size() > 0) {
			// System.out.println(queue);
			// System.out.println(dist);
			Integer u = getShortestDist(dist, queue);
			if (u != null) {
				// System.out.println(u);
				queue.remove(queue.indexOf(u));
				for (Integer i : this.nodes.get(u)) {
					Double newDist = dist.get(u) + 1.0;
					if (newDist < dist.get(i)) {
						dist.put(i, newDist);
						prev.put(i, u);
					}
				}
			} else {
				if (dist.get(p2) != Double.POSITIVE_INFINITY) {
					return dist.get(p2);
				} else {
					// Find longest distance, use that, to not create an outlier
					Double maxD = 0.0;
					for (Integer d : dist.keySet()) {
						if (dist.get(d) > maxD && dist.get(d) != Double.POSITIVE_INFINITY) {
							maxD = dist.get(d);
						}
					}
					return maxD;
				}
			}
		}
		return dist.get(p2);
	}
	
	public void setCorrelation(Map<String, Double> corrApp, Map<String, Double> corrGw, double limApp,double limGws) {
		//Find parameters of interest
		//appWeights gwWeights
		
		//Apps
		for (String name: corrApp.keySet()){
			if (Math.abs(corrApp.get(name))>limApp){
				appWeights.put(name, Math.abs(corrApp.get(name)));
			}
		}
		//Gateways
		for (String name: corrGw.keySet()){
			if (Math.abs(corrGw.get(name))>limGws){
				gwWeights.put(name, Math.abs(corrGw.get(name)));
			}
		}
		
		//Adjust so that their sum is 1 (why dunno, seems to make sense to me)
		double sum1=0.0;
		for (String name: appWeights.keySet()){
			sum1+=appWeights.get(name);
		}
		for (String name: appWeights.keySet()){
			appWeights.put(name,appWeights.get(name)/sum1);
		}
		double sum2=0.0;
		for (String name: gwWeights.keySet()){
			sum2+=gwWeights.get(name);
		}
		for (String name: gwWeights.keySet()){
			gwWeights.put(name,gwWeights.get(name)/sum2);
		}
		
		System.out.println("Corr App: "+appWeights+" Corr Gw:"+gwWeights);
	}
	
	
	public List<Integer> getNeighbours(Integer p, Float eps, Integer lvl) {
		// TODO Need to Reimplement all of this
		List<Integer> neighbour = new ArrayList<>();
		for (Integer a : this.fog.getApps().keySet()) {
			double tmp = 0.0;
			for (String name : appWeights.keySet()) {
				if (a != p) {
					switch (name) {
					case "Distance":
						tmp += this.dijkstraSearsch(p, a) * appWeights.get(name);
						break;
					case "ResourceShare":
						tmp += this.getResShare(p, a) * appWeights.get(name);
						break;
					case "Constraints":
						tmp += this.getConstSim(p, a) * appWeights.get(name);
						break;
					case "MessageRate":
						tmp += this.getMsgRateComp(p, a) * appWeights.get(name);
						break;
					case "UnitLoad":
						tmp += this.getUnitLoadComp(p, a) * appWeights.get(name);
						break;
					case "UtilityWeights":
						tmp += this.getUtilityComp(p, a) * appWeights.get(name);
						break;
					case "RequirementSim":
						tmp += this.getReqComp(p, a) * appWeights.get(name);
						break;
					}
				}
			}
			if (tmp > eps) {
				neighbour.add(a);
			}
		}
		return neighbour;
	}

	public double distanceToCluster(Integer p, Set<Integer> clustP) {
		//Same as Before just for a cluster and not apps
		double tmp = 0.0;
		for (Integer a : clustP) {
			for (String name : appWeights.keySet()) {
				if (a != p) {
					switch (name) {
					case "Distance":
						tmp += this.dijkstraSearsch(p, a) * appWeights.get(name);
						break;
					case "ResourceShare":
						tmp += this.getResShare(p, a) * appWeights.get(name);
						break;
					case "Constraints":
						tmp += this.getConstSim(p, a) * appWeights.get(name);
						break;
					case "MessageRate":
						tmp += this.getMsgRateComp(p, a) * appWeights.get(name);
						break;
					case "UnitLoad":
						tmp += this.getUnitLoadComp(p, a) * appWeights.get(name);
						break;
					case "UtilityWeights":
						tmp += this.getUtilityComp(p, a) * appWeights.get(name);
						break;
					case "RequirementSim":
						tmp += this.getReqComp(p, a) * appWeights.get(name);
						break;
					}
				}
			}
		}
		return tmp/clustP.size();
	}
}
