package org.nandor.spark;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import org.apache.avro.ipc.generic.GenericResponder;

public class AdvancedCls extends Clustering {
	
	protected float fractioned = (float)0.35;
	protected float locality = (float) 0.70;
	
	public AdvancedCls(Fog f) {
		super(f);
	}

	public void distributeGw2Cluster(){
		//Concepts: First Come first Serve
		//Concepts: Minimum Fraction Allowed to have a share of
		//Dependent (Singular, Shared) and Independent Gateways, independent ones can be allocated at will 
		this.fog.clearGwClustConns();
		Float totFreeGw = this.fog.getTotalFreeCapacity();
		Float totLoad = this.fog.getTotalLoad();
		Float ratio = totFreeGw/totLoad;
		Map<Integer, List<Integer>> locGws = new HashMap<>();
		//Getting Appropriate number of locality based important Gateways
		for (Integer c: this.fog.getClusters().keySet())
		{
			Float clsLoad = this.fog.getClusters().get(c).getClusterLoad();
			//System.out.println("Cluster: "+c+"Apps: "+this.fog.getClusters().get(c).getApps().keySet()+" Load: "+this.fog.getClusters().get(c).getClusterLoad());
			Map<Integer, Integer> gwRes = this.fog.getClusters().get(c).getGwResourcesCount();
			locGws.put(c, new ArrayList<>());
			Float allocLoad = (float) 0.0;
			//System.out.println(gwRes);
			while (allocLoad<clsLoad*ratio*locality && !gwRes.isEmpty()){
				int bestIndi = 0;
				int bestIndId = 0;
				for (Integer g: gwRes.keySet()){
					if (gwRes.get(g) > bestIndi){
						bestIndi = gwRes.get(g);
						bestIndId = g;
					}
				}
				locGws.get(c).add(bestIndId);
				gwRes.remove(bestIndId);
				//System.out.println(bestIndId+" "+bestIndi);
				allocLoad+=(float)(100.0-this.fog.getGateways().get(bestIndId).getGwLoad())*this.fog.getGateways().get(bestIndId).getPjCap();				
			}
			//System.out.println("Gws: "+locGws+" AllocLoad: "+allocLoad );
		}
		//Finding Gateways that are of the three types
		ArrayList<Integer> freeGws = new ArrayList<Integer>(this.fog.getGateways().keySet());
		ArrayList<Integer> sharedGws = new ArrayList<>();
		for (Integer g: locGws.keySet()){
			for (Integer g1: locGws.get(g)){
				if (freeGws.contains(g1)){
					freeGws.remove(g1);
				}else{
					if (!sharedGws.contains(g1)){
						sharedGws.add(g1);
					}
				}
			}
		}
		//Removing the average shared one 
		for (Integer gShare: sharedGws){
			boolean found = false;
			//Leave at first then remove from rest
			List<Integer> i = new ArrayList<Integer>(locGws.keySet());
			Collections.shuffle(i);
			for (Integer g: i){
				List<Integer> j = new ArrayList<Integer>(locGws.get(g));
				for (Integer g1: j){
					if (g1==gShare && !found){
						found = true;
					}else if (g1==gShare && found){
						locGws.get(g).remove(gShare);
					}
				}
			}
		}
		System.out.println(locGws);
		System.out.println(freeGws);
		System.out.println(sharedGws);
		//TODO
		//Do Final Allocations of Gws to Clusters
		Map<Integer,Float> shareLeft = new HashMap<>();
		for (Integer c: locGws.keySet()){
		{
			//Allocate each individual Gw to Cluster and calculate how much is needed and add all full portions 
			System.out.println("Cluster: "+c);
			Float allocRes = (float) 0.0;
			List<Integer> j = new ArrayList<Integer>(locGws.get(c));
			for (Integer g:j){
				Float res = (100 - this.fog.getGateways().get(g).getGwLoad());
				if(allocRes+res<this.fog.getClusters().get(c).getClusterLoad()*0.95*ratio){
					allocRes+=res;
				}else{
					locGws.get(c).remove(g);
					freeGws.add(g);
				}
			}
		}
		//Chekc how the final gateways Behave and how those are split up, maybe they should be shared 
	}
	
	
}
