package org.nandor.spark;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.TimeUnit;

import org.apache.avro.ipc.generic.GenericResponder;

public class AdvancedCls extends Clustering {
	
	protected float fractioned = (float)15.0;
	protected float locality = (float) 0.70;
	
	public AdvancedCls(Fog f) {
		super(f);
	}

	//Distance for Neighbours version 2
	public List<Integer> getNeighbours2(Integer p, Integer eps, Integer lvl){
		List<Integer> neighbour = new ArrayList<>();
		// Need to Determine what We care about when looking at distance, have weights for these 
		//Need to be able to find all points in the system, and give a distance to them based on these,
		// Find an eps value to which this fits.
		return neighbour;
	}
	public double distanceToCluster2(Integer p,Set<Integer> clustP){
		//Modify how distance of rogue or Noise nodes is calculated to clusters (based on previous
		
		return null;
	}
	
	//Distribution Version 2
	public void distributeGw2Cluster(){
		//Concepts: First Come first Serve
		//Concepts: Minimum Fraction Allowed to have a share of
		//Dependent (Singular, Shared) and Independent Gateways, independent ones can be allocated at will 
		this.fog.clearGwClustConns();
		Float totFreeGw = this.fog.getTotalFreeCapacity();
		Float totLoad = this.fog.getTotalLoad();
		Float ratio = totFreeGw/totLoad;
		Map<Integer, List<Integer>> locGws = new HashMap<>();
		//Getting Appropriate number of locality based important Gateways
		for (Integer c: this.fog.getClusters().keySet())
		{
			Float clsLoad = this.fog.getClusters().get(c).getClusterLoad();
			//System.out.println("Cluster: "+c+"Apps: "+this.fog.getClusters().get(c).getApps().keySet()+" Load: "+this.fog.getClusters().get(c).getClusterLoad());
			Map<Integer, Integer> gwRes = this.fog.getClusters().get(c).getGwResourcesCount();
			locGws.put(c, new ArrayList<>());
			Float allocLoad = (float) 0.0;
			//System.out.println(gwRes);
			while (allocLoad<clsLoad*ratio*locality && !gwRes.isEmpty()){
				int bestIndi = 0;
				int bestIndId = 0;
				for (Integer g: gwRes.keySet()){
					if (gwRes.get(g) > bestIndi){
						bestIndi = gwRes.get(g);
						bestIndId = g;
					}
				}
				locGws.get(c).add(bestIndId);
				gwRes.remove(bestIndId);
				//System.out.println(bestIndId+" "+bestIndi);
				allocLoad+=(float)(100.0-this.fog.getGateways().get(bestIndId).getGwLoad())*this.fog.getGateways().get(bestIndId).getPjCap();				
			}
			//System.out.println("Gws: "+locGws+" AllocLoad: "+allocLoad );
		}
		//Finding Gateways that are of the three types
		ArrayList<Integer> freeGws = new ArrayList<Integer>(this.fog.getGateways().keySet());
		ArrayList<Integer> sharedGws = new ArrayList<>();
		for (Integer g: locGws.keySet()){
			for (Integer g1: locGws.get(g)){
				if (freeGws.contains(g1)){
					freeGws.remove(g1);
				}else{
					if (!sharedGws.contains(g1)){
						sharedGws.add(g1);
					}
				}
			}
		}
		//Removing the average shared one 
		for (Integer gShare: sharedGws){
			boolean found = false;
			//Leave at first then remove from rest
			List<Integer> i = new ArrayList<Integer>(locGws.keySet());
			Collections.shuffle(i);
			for (Integer g: i){
				List<Integer> j = new ArrayList<Integer>(locGws.get(g));
				for (Integer g1: j){
					if (g1==gShare && !found){
						found = true;
					}else if (g1==gShare && found){
						locGws.get(g).remove(gShare);
					}
				}
			}
		}
		//System.out.println(locGws);
		//System.out.println(freeGws);
		//System.out.println(sharedGws);
		//Do Final Allocations of Gws to Clusters
		Map<Integer,Float> shareLeft = new HashMap<>();
		for (Integer c: locGws.keySet()){
			//Allocate each individual Gw to Cluster and calculate how much is needed and add all full portions 
			//System.out.print("Cluster: "+c);
			Float allocRes = (float) 0.0;
			List<Integer> j = new ArrayList<Integer>(locGws.get(c));
			for (Integer g:j){
				Float res = (float)(100.0 - this.fog.getGateways().get(g).getGwLoad())*this.fog.getGateways().get(g).getPjCap();
				if(allocRes+res<this.fog.getClusters().get(c).getClusterLoad()*0.95*ratio){
					allocRes+=res;
				}else{
					locGws.get(c).remove(g);
					freeGws.add(g);
				}
			}
			//System.out.print(" 1. Alloc: "+allocRes+ " Tot: "+this.fog.getClusters().get(c).getClusterLoad()*0.95*ratio);
			//Add from free until full
			List<Integer> j2 = new ArrayList<Integer>(freeGws);
			for (Integer g:j2){
				Float res = (100 - this.fog.getGateways().get(g).getGwLoad())*this.fog.getGateways().get(g).getPjCap();
				if(allocRes+res<this.fog.getClusters().get(c).getClusterLoad()*0.95*ratio){
					allocRes+=res;
					locGws.get(c).add(g);
					freeGws.remove(g);
				}
			}
			//System.out.println(" 2. Alloc: "+allocRes+ " Tot: "+this.fog.getClusters().get(c).getClusterLoad()*0.95*ratio);
			shareLeft.put(c, this.fog.getClusters().get(c).getClusterLoad()*ratio-allocRes);
		}
		//System.out.println("Saving");
		//System.out.println(locGws);
		//System.out.println(freeGws);
		//System.out.println(shareLeft);
		//System.out.println(freeGws);
		// Do Actuall Allocations of Gws to Clusters everything here is 100% allocations.
		for (Integer c : locGws.keySet()) {
			for (Integer g : locGws.get(c)) {
				this.fog.getGateways().get(g).addCluster(this.fog.getClusters().get(c),(float)(100.0-this.fog.getGateways().get(g).getGwLoad()),(float)0.0);
				this.fog.getClusters().get(c).addGateway(this.fog.getGateways().get(g),(float)(100.0-this.fog.getGateways().get(g).getGwLoad()),(float)0.0);
			}
		}
		//Do remainder part
		Map<Integer,Float> allocGws = new HashMap<>();
		for (Integer g:freeGws){
			allocGws.put(g, this.fog.getGateways().get(g).getFreeLoad());
		}
		List<Integer> j3 = new ArrayList<Integer>(shareLeft.keySet());
		/*for (Integer c: j3){
			// Check if any gw can store this while retaining % of space left //fractioned = (float)0.35;
			for (Integer g:freeGws){
				if (allocGws.get(g)-fractioned > shareLeft.get(c)){
					allocGws.put(g, allocGws.get(g)-shareLeft.get(c));
					this.fog.getGateways().get(g).addCluster(this.fog.getClusters().get(c),shareLeft.get(c)/this.fog.getGateways().get(g).getPjCap(),(float)0.0);
					this.fog.getClusters().get(c).addGateway(this.fog.getGateways().get(g),shareLeft.get(c)/this.fog.getGateways().get(g).getPjCap(),(float)0.0);
					 shareLeft.remove(c);
					 break;
				}else if (allocGws.get(g)*0.95 < shareLeft.get(c) && allocGws.get(g)*1.05 > shareLeft.get(c)){
					allocGws.put(g, allocGws.get(g)-shareLeft.get(c));
					this.fog.getGateways().get(g).addCluster(this.fog.getClusters().get(c),(float)(100.0-this.fog.getGateways().get(g).getGwLoad()),(float)0.0);
					this.fog.getClusters().get(c).addGateway(this.fog.getGateways().get(g),(float)(100.0-this.fog.getGateways().get(g).getGwLoad()),(float)0.0);
					 shareLeft.remove(c);
					 break;
				}
			}
		}*/
		//System.out.println(shareLeft);
		//System.out.println(allocGws);
		//Give Up Fill-Em Up
		for (Integer c: shareLeft.keySet()){
			Float req=shareLeft.get(c);			
			while (req>1.0 && allocGws.size()>0){
				Integer iter = allocGws.keySet().iterator().next();
				if (allocGws.get(iter)>req){
					allocGws.put(iter,allocGws.get(iter)-req); 
					this.fog.getGateways().get(iter).addCluster(this.fog.getClusters().get(c),req/this.fog.getGateways().get(iter).getPjCap(),(float)0.0);
					this.fog.getClusters().get(c).addGateway(this.fog.getGateways().get(iter),req/this.fog.getGateways().get(iter).getPjCap(),(float)0.0);
					req=(float)0.0;
				}else{
					req=req-allocGws.get(iter);
					this.fog.getGateways().get(iter).addCluster(this.fog.getClusters().get(c),allocGws.get(iter)/this.fog.getGateways().get(iter).getPjCap(),(float)0.0);
					this.fog.getClusters().get(c).addGateway(this.fog.getGateways().get(iter),allocGws.get(iter)/this.fog.getGateways().get(iter).getPjCap(),(float)0.0);
					allocGws.remove(iter);
				}
			}
		}
		//System.out.println(shareLeft);
		//System.out.println(allocGws);
	}
	
	public void resolveAnomalies(){
		
		// Delete all rubbish allocations
		//Redistribute things to make sane
		for (Integer g: this.fog.getGateways().keySet())
		{
			Iterator<Integer> i = new TreeSet<Integer>(this.fog.getGateways().get(g).getAllClusterShare().keySet()).iterator();
			while (i.hasNext()){
				Integer share = i.next();
				if (this.fog.getGateways().get(g).getAllClusterShare().get(share)<fractioned){
					this.fog.getGateways().get(g).removeCluster(this.fog.getClusters().get(share));
					this.fog.getClusters().get(share).removeGateway(this.fog.getGateways().get(g));
				}
			}
			this.fog.getGateways().get(g).filleavenClusters();
		}
	}
	
}
