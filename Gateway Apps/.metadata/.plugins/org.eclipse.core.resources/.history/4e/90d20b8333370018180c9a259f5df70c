package org.nandor.spark;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

public class WeightedCls extends Clustering{

	protected Map<String, Double> simWeights = new HashMap<>();
	
	public WeightedCls(Fog f) {
		super(f);
	}
	//Connections in a way that is not directional
	public Map<Integer,List<Integer>> getConnections(){
		Map<Integer,List<Integer>> nodes = new HashMap<>();
		for (Integer p: this.fog.getApps().keySet()){
			if (nodes.containsKey(p)){
				nodes.get(p).addAll(this.fog.getApps().get(p).getApps().keySet());
			}else{
				List<Integer> point = new ArrayList<>();
				point.addAll(this.fog.getApps().get(p).getApps().keySet());
				nodes.put(p, point);
			}
			for (Integer pBack: this.fog.getApps().get(p).getApps().keySet()){
					if (nodes.containsKey(pBack)){
						nodes.get(pBack).add(p);
					}else{
						List<Integer> pointBack = new ArrayList<>();
						pointBack.add(p);
						nodes.put(pBack, pointBack);
					}
				}
		}
		for (Integer p: nodes.keySet()){
			List<Integer> deDupStringList = new ArrayList<>(new HashSet<>(nodes.get(p)));
			nodes.put(p, deDupStringList);
			
		}
		//System.out.println(nodes);
		return nodes;
	}

	public  Map<String, Double> getSimilarities(Integer p1,Integer p2){	
		//Inti
		Map<String,Double> ret = new HashMap<>();
		/*
		 * Need to make sure that these methods and non-directional so dist p1-p2 == dist p2-p1 in all cases
		 * The values found can be totally arbitrary as later on they will be compared to a min and max in the 
		 * and given weights based on correlation parameters 
		 */
		//Connection Distance
		ret.put("Distance", this.dijkstraSearsch(p1, p2));
		//Resource Location share
		ret.put("ResourceShare",this.getResShare(p1,p2));
		//Constraint Component
		ret.put("Constraints",this.getConstSim(p1,p2));
		//Msg Rate
		ret.put("MessageRate",this.getMsgRateComp(p1,p2));
		//Unit Load
		ret.put("UnitLoad",this.getUnitLoadComp(p1,p2));
		//Utility Weights ratio
		ret.put("UtilityWeights",this.getUtilityComp(p1,p2));
		//Requirements
		ret.put("RequirementSim",this.getReqComp(p1,p2));
		
		//Return
		return ret;
	}
	
	private Double getResShare(Integer p1, Integer p2) {
		Double sim = 0.0;
		Double sim2 = 0.0;
		boolean found = false;
		//Find all Resources that share a gw from p1 to p2
		for (Integer res: this.fog.getApps().get(p1).getResources().keySet()){
			for (Integer res2: this.fog.getApps().get(p2).getResources().keySet()){
				if (this.fog.getResources().get(res).getGateway().getId()==this.fog.getResources().get(res2).getGateway().getId()){
					sim+=1.0;
					break;
				}
			}
		}
		//Find all Resources that share a gw from p2 to p1
		for (Integer res: this.fog.getApps().get(p2).getResources().keySet()){
			for (Integer res2: this.fog.getApps().get(p1).getResources().keySet()){
				if (this.fog.getResources().get(res).getGateway().getId()==this.fog.getResources().get(res2).getGateway().getId()){
					sim2+=1.0;
					break;
				}
			}
		}
		/*System.out.println(sim);
		System.out.println(sim2);
		System.out.println(this.fog.getApps().get(p1).getResources().size());
		System.out.println(this.fog.getApps().get(p2).getResources().size());*/
		//Return the number of resources shared for each app divided by total and multiplied 
		//ret = share1/tot1 * share2/tot2; where 
		//share[x] - total number of resources for app x that shares a gw with the other app; tot[x]-tot res count
		Double ret = sim/this.fog.getApps().get(p1).getResources().size()*sim2/this.fog.getApps().get(p2).getResources().size();
		return ret;
	}
	
	private Double getConstSim(Integer p1, Integer p2) {
		// Check if they have constraints or not, and if they have these on the same thing
		for (String ct: this.fog.getApps().get(p1).getConstraints().keySet()){
			if (this.fog.getApps().get(p2).getConstraints().get(ct)!=null){
				
			}
		}
		return null;
	}
	
	private Double abs(Double val1,Double val2){
		//Get RelativeDiffrence of two numbers
		// RelDiff = | x - y | / max(|x|,|y|)
		
	}
	
	private Double getMsgRateComp(Integer p1, Integer p2) {
		// TODO Auto-generated method stub
		return null;
	}
	
	private Double getUnitLoadComp(Integer p1, Integer p2) {
		// TODO Auto-generated method stub
		return null;
	}
	private Double getUtilityComp(Integer p1, Integer p2) {
		// TODO Auto-generated method stub
		return null;
	}
	private Double getReqComp(Integer p1, Integer p2) {
		// TODO Auto-generated method stub
		return null;
	}
	
}
